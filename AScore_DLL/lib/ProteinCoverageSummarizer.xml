<?xml version="1.0"?>
<doc>
<assembly>
<name>
ProteinCoverageSummarizer
</name>
</assembly>
<members>
<member name="T:ProteinCoverageSummarizer.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:ProteinCoverageSummarizer.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:ProteinCoverageSummarizer.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.ProteinName">
 <summary>
 Protein name (optional)
 </summary>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.PeptideSequence">
 <summary>
 Peptide amino acids (stored as uppercase letters)
 </summary>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.Prefix">
 <summary>
 Prefix residue
 </summary>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.Suffix">
 <summary>
 Suffix residue
 </summary>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.PeptideSequenceLtoI">
 <summary>
 Peptide sequence where leucines have been changed to isoleucine
 </summary>
 <remarks>Only used if mIgnoreILDifferences is True</remarks>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.PrefixLtoI">
 <summary>
 Prefix residue; if leucine, changed to isoleucine
 </summary>
 <remarks>Only used if mIgnoreILDifferences is True</remarks>
</member>
<member name="F:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.SuffixLtoI">
 <summary>
 Suffix residue; if leucine, changed to isoleucine
 </summary>
 <remarks>Only used if mIgnoreILDifferences is True</remarks>
</member>
<member name="M:ProteinCoverageSummarizer.clsLeaderSequenceCache.udtPeptideSequenceInfoType.ToString">
 <summary>
 Show the peptide sequence, including prefix and suffix
 </summary>
 <returns></returns>
</member>
<member name="M:ProteinCoverageSummarizer.clsLeaderSequenceCache.CachePeptide(System.String,System.String,System.Char,System.Char)">
 <summary>
 Caches the peptide and updates mLeaderSequences
 </summary>
 <param name="strPeptideSequence"></param>
 <param name="strProteinName"></param>
 <param name="chPrefixResidue"></param>
 <param name="chSuffixResidue"></param>
 <returns></returns>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinCoverageSummarizer.ConstructOutputFilePath(System.String,System.String,System.String,System.String)">
 <summary>
 Construct the output file path
 The output file is based on outputFileBaseName if defined, otherwise is based on inputFilePath with the suffix removed
 In either case, suffixToAppend is appended
 The Output fodler is based on outputFolderPath if defined, otherwise it is the folder where inputFilePath resides
 </summary>
 <param name="inputFilePath"></param>
 <param name="suffixToAppend"></param>
 <param name="outputFolderPath"></param>
 <param name="outputFileBaseName"></param>
 <returns></returns>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinCoverageSummarizer.FindSequenceMatchForPeptideList(System.Collections.Generic.IDictionary{System.String,System.Int32},System.String)">
 <summary>
 Searches for proteins that contain the peptides in peptideList
 If strProteinNameForPeptide is blank or mSearchAllProteinsForPeptideSequence=True then searches all proteins
 Otherwise, only searches protein strProteinNameForPeptide
 </summary>
 <param name="peptideList">Dictionary containing the peptides to search; peptides must be in the format Prefix.Peptide.Suffix where Prefix and Suffix are single characters; peptides are assumed to only contain letters (no symbols)</param>
 <param name="strProteinNameForPeptides">The protein to search; only used if mSearchAllProteinsForPeptideSequence=False</param>
 <remarks></remarks>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinCoverageSummarizer.GetOutputFolderPath(System.String,System.String)">
 <summary>
 Determine the output folder path
 Uses strOutputFolderPath if defined
 Otherwise uses the folder where strOutputFilePath resides
 </summary>
 <param name="strOutputFolderPath"></param>
 <param name="strOutputFilePath"></param>
 <returns></returns>
 <remarks>If an error, or unable to determine a folder, returns the folder with the application files</remarks>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinCoverageSummarizer.IncrementCountByKey(System.Collections.Generic.IDictionary{System.String,System.Int32},System.String)">
 <summary>
 Increment the observation count for the given key in the given dictionary
 If the key is not defined, add it
 </summary>
 <param name="oDictionary"></param>
 <param name="key"></param>
 <returns>True if the protein is new and was added tomProteinPeptideStats </returns>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinCoverageSummarizer.ReadProteinInfoChunk(System.Int32,System.Boolean[],System.Boolean)">
 <summary>
 Read the next chunk of proteins from the database (SequenceID, ProteinName, ProteinSequence)
 </summary>
 <returns>The number of records read</returns>
 <remarks></remarks>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinCoverageSummarizer.ValidateColumnCountInInputFile(System.String,ProteinCoverageSummarizer.clsProteinCoverageSummarizer.ePeptideFileColumnOrderingCode@,System.Boolean,System.Char)">
 <summary>
 Read the first two lines to check whether the data file actually has only one column when the user has
 specified mPeptideFileColumnOrdering = ePeptideFileColumnOrderingCode.ProteinName_PeptideSequence
 If mPeptideFileColumnOrdering = ePeptideFileColumnOrderingCode.SequenceOnly, the file isn't even opened
 </summary>
 <param name="strPeptideInputFilePath"></param>
 <param name="ePeptideFileColumnOrdering">Input / Output parameter</param>
 <param name="blnSkipFirstLine"></param>
 <param name="chColumnDelimiter"></param>
 <returns>True if no problems; False if the user chooses to abort</returns>
</member>
<member name="P:ProteinCoverageSummarizer.clsProteinFileDataCache.AssumeDelimitedFile">
 <summary>
 When True, assume the input file is a tab-delimited text file
 </summary>
 <returns></returns>
 <remarks>Ignored if AssumeFastaFile is True</remarks>
</member>
<member name="P:ProteinCoverageSummarizer.clsProteinFileDataCache.AssumeFastaFile">
 <summary>
 When True, assume the input file is a FASTA text file
 </summary>
 <returns></returns>
</member>
<member name="M:ProteinCoverageSummarizer.clsProteinFileDataCache.IsFastaFile(System.String)">
 <summary>
 Examines the file's extension and true if it ends in .fasta or .fsa or .faa
 </summary>
 <param name="strFilePath"></param>
 <returns></returns>
</member>
</members>
</doc>
